name: Documentation

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  # Build and Deploy Documentation
  docs:
    name: Build and Deploy Docs
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pages: write
      id-token: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for proper versioning
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install MkDocs and plugins
      run: |
        python -m pip install --upgrade pip
        pip install mkdocs mkdocs-material mkdocs-mermaid2-plugin
        
    - name: Build documentation
      run: |
        mkdocs build
        
    - name: Setup Pages
      if: github.ref == 'refs/heads/main'
      uses: actions/configure-pages@v4
      
    - name: Upload artifact
      if: github.ref == 'refs/heads/main'
      uses: actions/upload-pages-artifact@v3
      with:
        path: ./site
        
    - name: Deploy to GitHub Pages
      if: github.ref == 'refs/heads/main'
      uses: actions/deploy-pages@v4

  # Documentation Linting
  docs-lint:
    name: Documentation Linting
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install documentation tools
      run: |
        python -m pip install --upgrade pip
        pip install mkdocs mkdocs-material
        
    - name: Lint Markdown files
      run: |
        # Check for broken links (non-strict mode to allow warnings)
        mkdocs build
        
    - name: Check documentation structure
      run: |
        # Verify all referenced files exist
        python -c "
        import os
        import re
        
        def check_links():
            broken_links = []
            for root, dirs, files in os.walk('docs'):
                for file in files:
                    if file.endswith('.md'):
                        filepath = os.path.join(root, file)
                        with open(filepath, 'r', encoding='utf-8') as f:
                            content = f.read()
                            # Find markdown links
                            links = re.findall(r'\[([^\]]+)\]\(([^)]+)\)', content)
                            for text, link in links:
                                if link.startswith('http'):
                                    continue
                                if link.startswith('#'):
                                    continue
                                
                                # Resolve link path correctly
                                if link.startswith('docs/'):
                                    link_path = link
                                else:
                                    # For relative links, resolve relative to the current file's directory
                                    current_dir = os.path.dirname(filepath)
                                    # Use os.path.normpath and replace for cross-platform compatibility
                                    normalized_dir = os.path.normpath(current_dir).replace(os.sep, '/')
                                    if normalized_dir.startswith('docs/'):
                                        # For files in docs/, resolve relative to their directory
                                        link_path = normalized_dir + '/' + link
                                    else:
                                        link_path = os.path.join('docs', link)
                                
                                # Strip anchor fragment before checking file existence
                                if '#' in link_path:
                                    link_path = link_path.split('#')[0]
                                
                                # Normalize path to handle ../ and ./
                                link_path = os.path.normpath(link_path).replace(os.sep, '/')
                                
                                if not os.path.exists(link_path):
                                    broken_links.append(f'{filepath}: {text} -> {link}')
            
            if broken_links:
                print('Broken links found:')
                for link in broken_links:
                    print(f'  {link}')
                exit(1)
            else:
                print('All links are valid!')
        
        check_links()
        "

  # Documentation Testing
  docs-test:
    name: Documentation Testing
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements-test.txt
        
    - name: Test documentation examples
      run: |
        # Test code examples in documentation
        python -c "
        import os
        import re
        
        def test_code_examples():
            for root, dirs, files in os.walk('docs'):
                for file in files:
                    if file.endswith('.md'):
                        filepath = os.path.join(root, file)
                        with open(filepath, 'r', encoding='utf-8') as f:
                            content = f.read()
                            # Find code blocks
                            code_blocks = re.findall(r'```python\n(.*?)\n```', content, re.DOTALL)
                            for i, code in enumerate(code_blocks):
                                try:
                                    compile(code, f'{filepath}:block_{i}', 'exec')
                                    print(f'✓ Code block {i} in {filepath} is valid')
                                except SyntaxError as e:
                                    print(f'✗ Syntax error in {filepath}:block_{i}: {e}')
                                    exit(1)
        
        test_code_examples()
        print('All code examples are syntactically valid!')
        "