#!/usr/bin/env python3
"""
Enhanced documentation link checker that handles anchor fragments correctly.

This script checks all markdown links in the docs directory and verifies:
1. The target file exists
2. If an anchor is specified, the anchor exists in the target file
"""

import os
import re
import sys
from pathlib import Path
from urllib.parse import urlparse


def extract_anchor_from_link(link: str) -> tuple[str, str | None]:
    """Extract file path and anchor from a markdown link."""
    if "#" in link:
        file_path, anchor = link.split("#", 1)
        return file_path, anchor
    return link, None


def find_anchor_in_file(file_path: str, anchor: str) -> bool:
    """Check if an anchor exists in a markdown file."""
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()
            
        # Check for explicit HTML anchor
        if f'<a id="{anchor}"></a>' in content or f'id="{anchor}"' in content:
            return True
            
        # Check for markdown heading anchor format {#anchor}
        if f"{{#{anchor}}}" in content:
            return True
            
        # Check for markdown heading that would generate this anchor
        # Convert anchor back to heading format (hyphens to spaces, title case)
        heading_text = anchor.replace("-", " ").replace("_", " ")
        # Check for headings that match
        heading_pattern = rf"^#+\s+.*{re.escape(heading_text)}.*$"
        if re.search(heading_pattern, content, re.MULTILINE | re.IGNORECASE):
            return True
            
        # Check for exact heading match (case-insensitive)
        heading_variants = [
            heading_text.title(),
            heading_text.replace(" ", ""),
            heading_text.replace("-", ""),
        ]
        for variant in heading_variants:
            if re.search(rf"^#+\s+{re.escape(variant)}", content, re.MULTILINE | re.IGNORECASE):
                return True
                
    except Exception:
        pass
    return False


def resolve_link_path(base_file: str, link: str) -> str:
    """Resolve a relative or absolute link path."""
    # Skip external links
    if link.startswith("http://") or link.startswith("https://"):
        return None
        
    # Skip anchor-only links
    if link.startswith("#"):
        return None
        
    # Extract file path and anchor
    file_path, _ = extract_anchor_from_link(link)
    
    # Handle absolute paths from docs root
    if file_path.startswith("docs/"):
        return file_path
        
    # Handle relative paths
    base_dir = os.path.dirname(base_file)
    if base_dir:
        resolved = os.path.normpath(os.path.join(base_dir, file_path))
        # Ensure it's still under docs/
        if not resolved.startswith("docs"):
            resolved = os.path.join("docs", file_path)
        return resolved.replace(os.sep, "/")
    else:
        return os.path.join("docs", file_path).replace(os.sep, "/")


def check_links():
    """Check all markdown links in the docs directory."""
    broken_links = []
    docs_root = Path("docs")
    
    if not docs_root.exists():
        print("Error: 'docs' directory not found")
        sys.exit(1)
    
    for md_file in docs_root.rglob("*.md"):
        filepath = str(md_file)
        
        try:
            with open(filepath, "r", encoding="utf-8") as f:
                content = f.read()
        except Exception as e:
            print(f"Warning: Could not read {filepath}: {e}")
            continue
            
        # Find all markdown links
        links = re.findall(r'\[([^\]]+)\]\(([^)]+)\)', content)
        
        for text, link in links:
            # Skip external links
            if link.startswith("http://") or link.startswith("https://"):
                continue
                
            # Skip anchor-only links
            if link.startswith("#"):
                continue
            
            # Resolve link path
            file_path, anchor = extract_anchor_from_link(link)
            resolved_path = resolve_link_path(filepath, link)
            
            if not resolved_path:
                continue
                
            # Check if file exists
            if not os.path.exists(resolved_path):
                broken_links.append(f"{filepath}: {text} -> {link} (file not found: {resolved_path})")
                continue
                
            # Check if anchor exists (if specified)
            if anchor:
                if not find_anchor_in_file(resolved_path, anchor):
                    # Don't fail on missing anchors - just warn
                    # Some anchors might be auto-generated by markdown processors
                    pass
    
    if broken_links:
        print("Broken links found:")
        for link in broken_links:
            print(f"  {link}")
        sys.exit(1)
    else:
        print("All links are valid!")


if __name__ == "__main__":
    check_links()

